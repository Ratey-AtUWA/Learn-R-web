---
title: "Multivariate analysis"
subtitle: "Principal Components Analysis for Compositional Data"
author: "Andrew Rate"
date: "`r Sys.Date()`"
output: 
  html_document: 
    self_contained: no
    number_sections: no
    smart: no
    toc: no
---

<style type="text/css">
  body{
  font-size: 12pt;
}
</style>

```{r initialise-1, include=FALSE}
library(flextable); library(officer)

set_flextable_defaults(theme_fun = "theme_zebra", 
                       font.size = 9, fonts_ignore = TRUE)
BorderDk <- fp_border(color = "#B5C3DF", style = "solid", width = 1)
BorderLt <- fp_border(color = "#FFFFFF", style = "solid", width = 1)
source("https://github.com/Ratey-AtUWA/learn-R/raw/main/UWAcolgrad.R")
```

```{r load packages etc., message=FALSE, warning=FALSE, include=FALSE, results='hide'}
library(stringr)
library(car)
library(flextable)

palette(c("black", "#003087", "#DAAA00", "#8F92C4", "#E5CF7E", 
          "#001D51", "#B7A99F", "#A51890", "#C5003E", "#FDC596", 
          "#AD5D1E", "gray40", "gray85", "#FFFFFF", "transparent"))
```

# Understanding Compositional Data

Compositional data, defined as any measurements which are proportions of some
whole, are common in many disciplines, including (Table 1):

```{r table-compositional-data-examples, echo=FALSE}
CoDas <- data.frame(Discipline = c("Environmental science","Geography",
                                   "Geology and geochemistry","Biology","Politics"),
                    Examples = c("Sediment or soil texture - proportions of mineral grains in particle size range fractions", "Proportions of land area subject to different land uses","Elemental composition of rocks","Plant species abundance as a proportion of ground cover","Percentage of voters supporting each candidate"))
flextable(CoDas) |> 
  theme_zebra(odd_header = "#D0E0FF") |> 
  height_all(height=0.2, unit = "in") |> 
  hrule(rule = "exact") |> 
  width(j=1:2, width=c(2,5), unit = "in") |> 
  border_outer(border = BorderDk, part = "all") |>
  border_inner_v(border=BorderDk, part="header") |> 
  set_caption(caption="Table 1: Examples of compositional data by discipline. All of these examples of data have fixed-sum closure (see below).", align_with_table=F, fp_p=fp_par(text.align = "left", padding.bottom = 6))
```

&nbsp;

Compositional data have mathematical properties which result in misleading
conclusions from traditional statistical analyses. Compositional variables
(including concentrations of substances in water [or air, or rock, or soil, and
so on] or proportions of land surface coverage) are technically part of a
**fixed-sum closed set**. For example, with data on percent land use over an urban
area, all percentages add up to 100%! As Greenacre (2018) points out, we often
deal with *subcompositions* rather than compositions, because we do not (or can
not) measure all possible components of a sample. For example, in environmental
science, when we measure the substances present in water, we probably can't
measure everything, and we don't usually measure the concentration of water
itself. Or in politics, we report the proportions of voters who voted for each
candidate, but not often the proportion of citizens who didn't vote.

The issue of subcompositions is not necessarily a problem. For instance, in the 
political example above, the ratio of voters supporting the two leading 
candidates will be the same whether we consider the total eligible electors, or 
only the people who actually voted. As we will see below, a key strategy for 
analysing compositional data is the use of some sort of *ratio*.

If uncorrected, analysis of data having fixed-sum closure can lead to very
misleading conclusions, especially when *relationships* between variables are
being investigated, as in correlation analyses or *multivariate methods* such as
principal component analysis. Closed data require specialised transformations to
remove closure, such as calculation of **centered or additive log ratios**
(Reimann et al. 2008). The centered log-ratio is defined by:

$x_{CLR} = log(\dfrac{x}{geomean(x_{1},...,x_{n})})$, where 

- $x$ is the value being transformed (concentration, proportion);
- $x_{CLR}$ is the centered log-ratio transformed value;
- $geomean$ means the geometric mean of;
- $x_{1}...x_{n}$ are all the $n$ values contributing to the (sub)composition, including the one ($x$) being transformed;
- all the components (parts) of the composition need to be in **identical units** (*e.g*. percent, mg/L, incidence per 10,000, *etc*.).

For example, in a soil texture analysis where the proportions of grain size 
categories gravel (G), sand (S), silt (Z), and clay (C) all add up to 100%, the 
CLR-transformed sand content (*S~CLR~*) is:

$S_{CLR} = log(\dfrac{S}{geomean(G,S,Z,C)})$

The example in Figure 1 shows the relationship between phosphorus (P) and iron
(Fe) in soil/sediment materials in an acid sulfate environment. Without
correcting for compositional closure, the P *vs*. Fe plot implies that P
increases as Fe increases. Correcting for compositional closure, however,
suggests the opposite, with P negatively related to Fe! In this case, if we had
used conventional transformations, we might have come to a very wrong conclusion
about the sediment properties affecting phosphorus.

```{r closed open example P-Fe, echo=FALSE, fig.height=3.5, fig.width=7, message=FALSE, warning=FALSE, out.width="65%", fig.align='center', fig.cap="Figure 1: Comparison of relationships between P and Fe for (a) compositionally closed concentrations showing a positive relationship and (b) concentration variables corrected for compositional closure using centred log ratios showing a negative relationship. Data from Xu et al. (2018).", results='hold'}
nx.clr <- read.csv("nx_clr.csv", stringsAsFactors = TRUE)
par(mfrow=c(1,2), mar=c(3,3,1.,1), oma=c(0,0,0,0), mgp=c(1.4,0.1,0.0), lend=2, ljoin=1, 
    font.lab=2, cex.axis=1, cex.lab=1.1, cex=1., lwd=1, tcl=0.2)
palette(c("black","goldenrod2","royalblue4","gray92",
          "#EADBA4","#808BD6","gray50","#00083D","#51471D","gray24"))
# closed
plot(nx.clr$Fe.oes/1e3, nx.clr$P.oes, log="xy", pch=c(17,15)[nx.clr$Type],
     col=c(2,3)[nx.clr$Type],
     lwd=2, xlab=expression(bold(paste(Fe[closed]," (mg/kg \u00F7 1000)"))),
     ylab=expression(bold(paste(P[closed]," (mg/kg)"))))
mtext(side=2, line=1.4, expression(bold(paste(P[closed]," (mg/kg)"))), cex=1.1)
mtext("(a)", 3, -1.25, adj = 0.05, font = 2, cex = 1.1)
legend("left", bty = "n", legend = c("Dredge spoil","Sediment"),
       pch = c(17,15), col = c(2,3), pt.lwd = c(2,1), pt.cex = c(1,1.1))
# clr
plot(nx.clr$Fe, nx.clr$P, pch=c(17,15)[nx.clr$Type], col=c(2,3)[nx.clr$Type], lwd=2,
     xlab=expression(bold(paste(Fe[open]," (clr-transformed)"))),
     ylab=expression(bold(paste(P[open]," (clr-transformed)"))))
mtext("(b)", 3, -1.25, adj = 0.95, font = 2, cex = 1.1) 
```

&nbsp;

# Principal Components Analysis

To get started with understanding compositional data, and analysing them using
Principal Components Analysis, we load the packages we need, and set a preferred
colour palette.

```{r load-packages-notrun, message=FALSE, warning=FALSE, eval=FALSE}
library(stringr)     # manipulate character strings
library(car)         # statistical functions focused on regression
library(flextable)   # publication-quality tables

palette(c("black", "#003087", "#DAAA00", "#8F92C4", "#E5CF7E", 
          "#001D51", "#B7A99F", "#A51890", "#C5003E", "#FDC596", 
          "#AD5D1E", "gray40", "gray85", "white", "transparent"))
```

We also need to **read some data**:

**Data are from**: Fig. 11 *in* Hu, J., Wang, Y., TaubenbÃ¶ck, H., Zhu, X.X., 2021. Land consumption in cities: A comparative study across the globe. *Cities*, **113**: 103163, <https://doi.org/10.1016/j.cities.2021.103163>. (digitised from figure using <https://automeris.io/WebPlotDigitizer/>)

*If you were hoping for an example using geochemical-type compositional data &ndash; don't worry, we're going to repeat all the analyses [below using a geochemical dataset](#geochem)*.

After reading the data we make a column containing abbreviated codes for the
land-use type factor, using the `gsub()` function to substitute character
strings.

```{r read file and format data, echo=1:2, results='hold'}
cities <- 
  read.csv(paste0("https://raw.githubusercontent.com/Ratey-AtUWA/",
                  "compositional_data/main/cities_Hu_etal_2021.csv"), 
           stringsAsFactors = TRUE)
row.names(cities) <- as.character(cities$City)
cities$sType <- as.character(cities$Type)
cities$sType <- gsub("Compact-Open","CO",cities$sType)
cities$sType <- gsub("Open-Lightweight","OL",cities$sType)
cities$sType <- gsub("Compact","C",cities$sType)
cities$sType <- gsub("Open","O",cities$sType)
cities$sType <- gsub("Industrial","I",cities$sType)
cities$sType <- as.factor(cities$sType)
```

We also need to use a log-ratio transform to remove compositional fixed-sum 
closure:

```{r clr-transform data, paged.print=FALSE, results='hold'}
cities_clr <- cities
cities_clr[,2:5] <- t(apply(cities[,2:5], MARGIN = 1,
                           FUN = function(x){log(x) - mean(log(x))}))
```

## Explanation of principal components analysis

It is quite common to measure many variables in environmental science and other
disciplines. Using various types of *ordination analysis*, we can use the
information contained in multiple variables to create a reduced subset of
variables containing nearly the same amount of information. Ordination methods
are also referred to, for this reason, as 'data reduction' methods and are
commonly used for multivariate analysis.

One of the earliest and most widely used ordination methods for exploration and
dimension-reduction of multivariate data is **principal components analysis**
(PCA). Imagine a dataset with many samples (rows) and n continuous numeric
variables (columns) which contain quantitative information about each sample
such as concentrations, heights, velocities, *etc*. For these *n*
variables/dimensions, the principal component calculation generates *n* new
variables, or principal components, which are each a function of the set of all
the original variables (so each principal component is defined by a weighting or
coefficient for each of the original variables). We may choose to omit some
variables from the analysis if they contain too many missing observations or if
there is another valid reason to doubt their integrity. Since each principal
component is selected to account for successively smaller proportions of the
multiple variance, it is usually the first few principal components which
explain most of the variance and therefore contain the most useful information.
We conventionally visualize this in a 'scree plot' (Figure 2), a
kind of bar graph showing the decrease in variance accounted for by each
component.

Base-**R** has two functions which perform Principal Components Analysis (PCA).
We will use the `prcomp()` function which has better numerical accuracy and 
a more valid variance calculation than the alternative `princomp()` (see 
**Details** after running `?prcomp` for more information). We include the 
argument `scale. = TRUE`, as this is better for avoiding unexpected results due 
to large differences in magnitude of the variables.

```{r run and summarise PCA, results='hold'}
#
data0 <- na.omit(cities[,c("Compact","Open","Lightweight","Industry")])
pca_cities_clos <- prcomp(data0, scale. = TRUE)
cat("Variable weightings (rotations) - closed data\n")
pca_cities_clos$rot
cat("...\n\nComponent Variances - Closed data\n")
pca_cities_clos$sdev^2
cat("...\n\nProportions of variance explained by each component",
    "\nCLR-transformed (open) data\n")
round(pca_cities_clos$sdev^2/sum(pca_cities_clos$sdev^2),3)
cat("\n--------------------\nVariable weightings (rotations) - open data\n")

data0 <- na.omit(cities_clr[,c("Compact","Open","Lightweight","Industry")])
pca_cities_open <- prcomp(data0, scale. = TRUE)
pca_cities_open$rot
cat("...\n\nComponent Variances - CLR-transformed (open) data\n")
pca_cities_open$sdev^2
cat("...\n\nProportions of variance explained by each component",
    "\nCLR-transformed (open) data\n")
round(pca_cities_open$sdev^2/sum(pca_cities_open$sdev^2),3)
rm(data0)
```

As we should expect, each component accounts for successively less variance. We
can already see that removing closure has made a noticeable difference to the 
PCA output, both in the variable weightings and the component variances.

## Principal Components Analysis output

As well as the component variances, the useful results of principal components
analysis include the variable weightings or 'rotations' for each principal
component. Referring to just the output for **open data** above, PC1 (which
explains the most multivariate variance) has its greatest absolute contributions
from the Lightweight and Industry variables, which act in opposite directions
(remembering that the sign is arbitrary, but that *relative* sign and magnitude
are important). PC2 contains mainly variance from the Compact and Open
variables, PC3 (which explains much less variance) reflects Open/Industry, and
we can ignore PC4 as it has a negligible component variance.

In addition, every individual observation (sample) is a multivariate point, the
observation scores for all samples in each principal component based on the
values of the variables used in PCA for that sample. It is conventional to plot
both of these two types of output in a principal component **biplot**, as shown
in Figure 3. Before discussing the biplot, we should note that the
sign (positive or negative) of variable weightings and observation scores
(*i.e*. the direction of the axes) is arbitrary and should not affect our
interpretations.

```{r scree-plots-cities, echo=FALSE, fig.height=2.5, fig.width=6, message=FALSE, warning=FALSE, out.width='60%', fig.align='center', fig.cap="Figure 2: PCA scree plots for urban land-use data, for: (a) compositionally closed proportions; (b) data corrected for closure using CLR-transformation.", results='hold'}
par(mar = c(3.,3.5,1.2,1), mfrow = c(1,2), mgp=c(2,0.8,0), font.lab=2)
plot(pca_cities_clos, main = "(a) closed", cex.main = 1, col = 5)
axis(1, at=seq(0.8,4.2,l=4), labels=seq(1,4,1), tcl=0.01, col=15, mgp=c(0.5,0.1,0))
mtext("Component", side = 1, line = 1.15, font = 2)
plot(pca_cities_open, main = "(b) open (CLR)", cex.main = 1, col = 4)
axis(1, at=seq(0.8,4.2,l=4), labels=seq(1,4,1), tcl=0.01, col=15, mgp=c(0.5,0.1,0))
mtext("Component", side = 1, line = 1.15, font = 2)
par(mar = c(3.5,3.5,1,1), mfrow = c(1,2), mgp=c(1.7,0.3,0))
```

&nbsp;

There are informal 'rules' for deciding which of the principal components 
contain useful information:

1. Components having variance greater than 1 (the 'Kaiser' criterion)
2. Components up to a cumulative proportion of variance explained of 0.8 (80%)

For example, for the open data, the component variances are PC1 1.976, PC2
1.511, PC3 0.513, PC4 1.5E-31 -- so only PC1 and PC2 meet the first criterion.
Similarly, the *cumulative* proportions of variance explained by each component
are PC1 0.494, PC1+PC2 0.872, so by criterion 2 no useful information is
contained in principal components >2. In this example both criteria agree (they
don't always!).

Another part of the PCA output that we need to know about is the set of
*observation scores*, essentially showing where each observation (each city, in
these data) plots in principal component space. We're only interested in PC1 and
PC2, since they are the only components meeting the criteria. The observation
scores for the first rows of the data are as follows (Table 2):

```{r table-PCA-obs-scores-cities, results='hold'}
OScores <- data.frame(City=cities_clr$City[1:8],
                      PC1_closed=round(pca_cities_clos$x[1:8,1],3),
                      PC2_closed=round(pca_cities_clos$x[1:8,2],3),
                      PC1_open=round(pca_cities_open$x[1:8,1],3),
                      PC2_open=round(pca_cities_open$x[1:8,2],3))
flextable(OScores) |>
  theme_zebra(odd_header = "#D0E0FF", even_header = "#D0E0FF") |>
  border_outer(border = BorderDk, part = "all") |>
  border_inner_v(border=BorderLt, part="header") |> 
  set_caption(caption = "Table 2: PCA observation scores for the first 8 rows of the cities data (closed and open).", align_with_table=F, fp_p=fp_par(text.align = "left", padding.bottom = 6))
```

&nbsp;

## Principal components biplots

```{r visualise-PCA-cities, fig.height=6, fig.width=12, fig.align='center', fig.cap="Figure 3: PCA biplots for urban land-use data, with observations categorised by type for: (a) compositionally closed proportions; (b) data corrected for closure using CLR-transformation.", results='hold'}

require(car) # for data ellipses (see Fig 1.4)
palette(c("black",scico::scico(8, palette = "batlow", alpha = 0.7),"white"))
par(mfrow=c(1,2), mar = c(3.5,3.5,3.5,3.5), oma = c(0,0,0,0), 
    mgp=c(1.7,0.3,0), tcl = 0.25, font.lab=2,
    lend = "square", ljoin = "mitre")
# choose components and set scaling factor (sf)
v1 <- 1; v2 <- 2; sf <- 0.4

biplot(pca_cities_clos, choices = c(v1,v2), col = c(2,1), cex=c(1,0.0),
       pc.biplot = FALSE, scale = 0.4, arrow.len = 0.08,
       xlim = c(-1.5,1.5), ylim = c(-1.5,1.5),
       xlab = paste0("Scaled PC",v1," Component Loadings"),
       ylab = paste0("Scaled PC",v2," Component Loadings"))
mtext(paste0("Scaled PC",v1," Observation Scores"), 3, 1.6, font = 2)
mtext(paste0("Scaled PC",v2," Observation Scores"), 4, 1.6, font = 2)
mtext("Untransformed data\n(compositionally closed)",
      side = 3, line = -2, font = 2, adj = 0.98)
data0 <- na.omit(cities[,c("Type","Global","Region","Compact",
                           "Open","Lightweight","Industry")])
points(pca_cities_clos$x[,v1]*sf, pca_cities_clos$x[,v2]*sf*1.5,
       pch = c(21:25)[data0$Type],
       lwd = 1, bg = c(7,6,5,4,3)[data0$Type],
       col = 1,
       cex = c(1.4,1.3,1.2,1.2,1.2)[data0$Type])
dataEllipse(x=pca_cities_clos$x[,v1]*sf, y=pca_cities_clos$x[,v2]*sf*1.5,
            groups = data0$Type, add = TRUE, plot.points = FALSE, 
            levels = c(0.9), center.pch = 3, col = c(2,3,8,9,11),
            lty = 2, lwd = 1, center.cex = 2.4, group.labels = "")
legend("bottomright", bty = "o", inset = 0.03,
       box.col = "gray", box.lwd = 2, bg = 10,
       legend = levels(data0$Type),
       pch = c(21:25), pt.lwd = 1,
       col = 1, pt.bg = c(7,6,5,4,3),
       pt.cex = c(1.4, 1.3, 1.2,1.2,1.2),
       cex = 0.9, y.intersp = 0.9)
mtext("(a)", side = 3, line = -1.5, font = 2, adj = 0.02, cex = 1.25)

sf <- 0.25 # adjust scaling factor for next PCA biplot

biplot(pca_cities_open, choices = c(v1,v2), col = c(2,1), cex=c(0.8,1),
       pc.biplot = FALSE, scale = 0.2, arrow.len = 0.08,
       # xlim = c(-1.2,3.2), ylim = c(-3.5,1.7),
       xlab = paste0("Scaled PC",v1," Component Loadings"),
       ylab = paste0("Scaled PC",v2," Component Loadings")) 
mtext(paste0("Scaled PC",v1," Observation Scores"), 3, 1.6, font = 2)
mtext(paste0("Scaled PC",v2," Observation Scores"), 4, 1.6, font = 2)
mtext("CLR\ntransformed\ndata\n(no closure)",
      side = 3, line = -4, font = 2, adj = 0.98)
data0 <- na.omit(cities_clr[,c("Type","Compact","Open","Lightweight","Industry")])
points(pca_cities_open$x[,v1]*sf, pca_cities_open$x[,v2]*sf,
       pch = c(21:25)[data0$Type],
       lwd=2, bg = c(7,6,5,4,3)[data0$Type],
       col = c(1,1,1,1,1)[data0$Type],
       cex = c(1.4,1.3,1.2,1.2,1.2)[data0$Type])
dataEllipse(x=pca_cities_open$x[,v1]*sf, y=pca_cities_open$x[,v2]*sf*1.5,
            groups = data0$Type, add = TRUE, plot.points = FALSE, 
            levels = c(0.9), center.pch = 3, col = c(7,6,5,4,3),
            lty = 2, lwd = 2, center.cex = 2.4, group.labels = "")
legend("bottomright", bty = "o", inset = 0.03,
       box.col = "gray", box.lwd = 2, bg = 10,
       legend = levels(data0$Type),
       pch = c(21:251), pt.lwd = 2,
       col = 1, pt.bg = c(7,6,5,4,3),
       pt.cex = c(1.4, 1.3, 1.2,1.2,1.2),
       cex = 0.9, y.intersp = 0.9)
mtext("(b)", side = 3, line = -1.5, font = 2, adj = 0.02, cex = 1.25)
```

```{r remove temp PCA objects, message=FALSE, warning=FALSE, include=FALSE, echo=FALSE}
rm(list = c("v1","v2","sf","data0"))
```

&nbsp;

PCA biplots are useful, because the *variable weightings* group together for
variables (measurements) that are related to one another. For example, in the
biplots in Figure 3, the variables are relative land areas under 4
land-use categories (which have been corrected in Figure 3(b) for
compositional closure using the CLR transformation). These variables are shown
as vectors (arrows) in the biplot of principal components PC1 and PC2, and
variables which are related have vectors of similar length and/or direction. For
example, the variables 'Compact' and 'Industry' plot closely together on biplot
(a), suggesting some relationship between these land use categories. Removing
closure in our data (biplot (b)) seems to remove this relationship, so it is
probably not real! 

Often we see the component vectors arranged in an obviously
*asymmetric pattern* with closed data, and this is more apparent 
[further down this page](#geochem) when we analyse some geochemical data. (When
closure is removed, the vectors have a less asymmetric pattern - see 
[Figure 5](#biplot2) further below.)

The other main information we obtain from principal components biplots is from
the *observation scores* (see above). These will plot at locations similar to
their dominant variables: for example, in Figure 2(b), the 'Compact'
cities all plot towards the top of the biplot in the same direction as the
'Compact' variable weighting vector. This suggests that compact cities have
greater proportions of compact land use -- which should not be too surprising!
Note that in the biplot for closed data in Figure 2(a), the separation
of cities is not so clear.

#### Some other things to try

We could also group the observation scores in our biplot by a different factor
in our dataset. For example, it would be interesting to see if we could observe
any separation of cities by geographical region in the principal components
analysis. You might want to practice your **R** coding on this problem!

&nbsp;

# PCA on Geochemical Data

<p id="geochem">**Data edited from**: Rate & McGrath (2022a) (described in Rate & McGrath, 2022b).</p>

### First we read and curate the data...

```{r read-file-ashfield-data, results='hold'}
ashfield <- 
  read.csv(paste0("https://raw.githubusercontent.com/Ratey-AtUWA/",
                  "compositional_data/main/AFR_surfSed_2019-2021.csv"), 
           stringsAsFactors = TRUE)
ashfield$Year <- as.factor(ashfield$Year)
```

...and then apply a CLR-transformation to remove closure for the relevant set of
variables (*i.e*. the concentration variables in columns `11:38`: `Al`, `As`,
`Ba`, `Ca`, `Cd`, `Ce`, `Co`, `Cr`, `Cu`, `Fe`, `Gd`, `K`, `La`, `Li`, `Mg`,
`Mn`, `Mo`, `Na`, `Nd`, `Ni`, `P`, `Pb`, `S`, `Sr`, `Th`, `V`, `Y`, `Zn`.

For the closed data, all elements except Al, Cr, Fe, Gd, K, La, Li, Nd, Ni, Th, V, Y
are log~10~-transformed before
PCA to limit the effects of skewness (using `scale.=TRUE` won't change the shape
of variable distributions, unfortunately). We don't remove closure by
log~10~-transformation alone, though.

We also need to make a centered log ratio-transformed dataset.

```{r clr-transform-ashfield-data, paged.print=FALSE, results='hold'}
ashfield_clr <- ashfield
ashfield_clr[,11:38] <- t(apply(ashfield[,11:38], MARGIN = 1,
                                FUN = function(x){log(x) - mean(log(x), na.rm=TRUE)}))
head(ashfield_clr[,11:17])
```

### Running the geochemical PCA

We run the PCA using `prcomp()` using `scale. = TRUE` as before, for both closed
and CLR-transformed concentrations:

```{r run-output-ashfield-PCA, results='hold'}
data0 <- na.omit(ashfield[,c(3,4,11:38)])
forlog <- c("As","Ba","Ca","Cd","Ce","Co","Cu","Mg",
            "Mn","Mo","Na","P","Pb","S","Sr","Zn")
data0[,which(colnames(data0) %in% forlog==T)] <- 
  log10(data0[,which(colnames(data0) %in% forlog==T)]) # note log-transformation
pca_ashfield_clos <- prcomp(data0[,3:30], scale. = TRUE)
cat("Variable weightings (rotations) - Closed data (only simple transformations) (first 8 PCs, first 6 variables)\n")
head(pca_ashfield_clos$rot[,1:8])
cat("...\n\nComponent Variances - Closed data (only simple transformations)\n")
pca_ashfield_clos$sdev^2
cat("...\n\nProportions of variance explained by each component",
    "\nClosed data (only simple transformations)\n")
round(pca_ashfield_clos$sdev^2/sum(pca_ashfield_clos$sdev^2),3)
cat("\nCumulative proportions of variance explained by each component",
    "\nClosed data (only simple transformations)\n")
cumsum(round(pca_ashfield_clos$sdev^2/sum(pca_ashfield_clos$sdev^2),3))

cat("\n--------------------\nVariable weightings (rotations) - open data (first 8 PCs, first 6 variables)\n")
data0 <- na.omit(ashfield_clr[,c(3,4,11:38)])
pca_ashfield_open <- prcomp(data0[,3:30], scale. = TRUE)
head(pca_ashfield_open$rot[,1:8])
cat("...\n\nComponent Variances - CLR-transformed (open) data\n")
pca_ashfield_open$sdev^2
cat("...\n\nProportions of variance explained by each component",
    "\nCLR-transformed (open) data\n")
round(pca_ashfield_open$sdev^2/sum(pca_ashfield_open$sdev^2),3)
cat("\nCumulative proportions of variance explained by each component",
    "\nCLR-transformed (open) data\n")
cumsum(round(pca_ashfield_open$sdev^2/sum(pca_ashfield_open$sdev^2),3))
```

For both the closed and open data, we reach 80% of variance explained by component 6.

```{r scree-plots-ashfield, echo=FALSE, fig.height=3, fig.width=10, message=FALSE, warning=FALSE, out.width='80%', fig.align='center', fig.cap="Figure 4: PCA scree plots for Ashfield data, for: (a) compositionally closed concentrations (only simple transformations); (b) data corrected for closure using CLR-transformation.", results='hold'}
palette(c("black",UWAcolgrad(9, saturated = TRUE, alpha = 0.65)))
par(mar = c(3.,3.5,1.2,1), mfrow = c(1,2), mgp=c(2,0.8,0), font.lab=2)
plot(pca_ashfield_clos, main = "(a) closed", cex.main = 1, col = 7)
axis(1, at=seq(0.7,11.5,l=10), labels=seq(1,10,1), tcl=0.01, col=15, mgp=c(0.5,0.1,0))
abline(h=1,col="grey55",lty=3)
mtext("Component", side = 1, line = 1.15, font = 2)
plot(pca_ashfield_open, main = "(b) open (CLR)", cex.main = 1, col = 4)
axis(1, at=seq(0.7,11.5,l=10), labels=seq(1,10,1), tcl=0.01, col=15, mgp=c(0.5,0.1,0))
abline(h=1,col="grey25",lty=3)
mtext("Component", side = 1, line = 1.15, font = 2)
par(mar = c(3.5,3.5,1,1), mfrow = c(1,2), mgp=c(1.7,0.3,0))
```

Figure 4 shows that for this analysis, 6 components have variances &ge; 1, 
regardless of closure.

```{r table-PCA-obs-scores-ashfield, results='hold'}
OScores <- data.frame(Samp=ashfield_clr$SampID[1:8],
                      PC1_closed=round(pca_ashfield_clos$x[1:8,1],3),
                      PC2_closed=round(pca_ashfield_clos$x[1:8,2],3),
                      PC1_open=round(pca_ashfield_open$x[1:8,1],3),
                      PC2_open=round(pca_ashfield_open$x[1:8,2],3))
flextable(OScores) |>
  theme_zebra(odd_header = "#D0E0FF", even_header = "#D0E0FF") |>
  border_outer(border = BorderDk, part = "all") |>
  border_inner_v(border=BorderLt, part="header") |>
  set_caption(caption="Table 3: PCA observation scores for the first 8 rows of the Ashfield Flats data (closed and open).", align_with_table=F, fp_p=fp_par(text.align = "left", padding.bottom = 6))
```

&nbsp;

```{r visualise-PCA-ashfield, fig.height=6, fig.width=12, fig.align='center', fig.cap="Figure 5: PCA biplots for Ashfield data, with observations categorised by sample type for: (a) compositionally closed concentrations, log~10~ transformation only; (b) data corrected for closure using CLR-transformation.", results='hold'}
par(mfrow=c(1,2), mar = c(3.5,3.5,3.5,3.5), oma = c(0,0,0,0), 
    mgp=c(1.7,0.3,0), tcl = 0.25, font.lab=2,
    lend = "square", ljoin = "mitre")
# choose components and set scaling factor (s0)
v1 <- 1; v2 <- 2; s0 <- 0.12

biplot(pca_ashfield_clos, choices = c(v1,v2), col = c("#ffffff00",1), cex=c(1,0.0),
       pc.biplot = FALSE, scale = 0.4, arrow.len = 0.08,
       # xlim = c(-1.5,1.5), ylim = c(-1.2,1.2),
       xlab = paste0("Scaled PC",v1," Component Loadings"),
       ylab = paste0("Scaled PC",v2," Component Loadings"))
mtext(paste0("Scaled PC",v1," Observation Scores"), 3, 1.6, font = 2)
mtext(paste0("Scaled PC",v2," Observation Scores"), 4, 1.6, font = 2)
mtext("Untransformed data\n(compositionally closed)",
      side = 1, line = -2, font = 2, adj = 0.04)
data0 <- na.omit(ashfield[,c(3,4,9:38)])
points(pca_ashfield_clos$x[,v1]*s0, pca_ashfield_clos$x[,v2]*s0*1.5,
       pch = c(22,21,24)[data0$Type],
       lwd = 1, bg = c(6,4,2)[data0$Type],
       col = 1,
       cex = c(1.2,1.4,1)[data0$Type])
legend("bottomright", bty = "o", inset = 0.03,
       box.col = "gray", box.lwd = 2, bg = 10,
       legend = levels(data0$Type),
       pch = c(22,21,24), pt.lwd = 1
       ,
       col = 1, pt.bg = c(6,4,2),
       pt.cex = c(1.2, 1.4, 1),
       cex = 0.9, y.intersp = 0.9)
mtext("(a)", side = 3, line = -1.5, font = 2, adj = 0.02, cex = 1.25)

s0 <- 0.09 # adjust scaling factor for next PCA biplot

biplot(pca_ashfield_open, choices = c(v1,v2), col = c("transparent",1), cex=c(0.8,1),
       pc.biplot = FALSE, scale = 0.2, arrow.len = 0.08,
       # xlim = c(-1.2,3.2), ylim = c(-3.5,1.7),
       xlab = paste0("Scaled PC",v1," Component Loadings"),
       ylab = paste0("Scaled PC",v2," Component Loadings")) 
mtext(paste0("Scaled PC",v1," Observation Scores"), 3, 1.6, font = 2)
mtext(paste0("Scaled PC",v2," Observation Scores"), 4, 1.6, font = 2)
mtext("CLR-transformed\ndata (no closure)",
      side = 1, line = -2, font = 2, adj = 0.04)
data0 <- na.omit(ashfield_clr[,c(3,4,9:38)])
points(pca_ashfield_open$x[,v1]*s0, pca_ashfield_open$x[,v2]*s0,
       pch = c(22,21,24)[data0$Type],
       lwd = 1, bg = c(6,4,2)[data0$Type],
       col = 1,
       cex = c(1.2,1.4,1)[data0$Type])
legend("bottomright", bty = "o", inset = 0.03,
       box.col = "gray", box.lwd = 2, bg = 10,
       legend = levels(data0$Type),
       pch = c(22,21,24), pt.lwd = 1,
       col = 1, pt.bg = c(6,4,2),
       pt.cex = c(1.2, 1.4, 1),
       cex = 0.9, y.intersp = 0.9)
mtext("(b)", side = 3, line = -1.5, font = 2, adj = 0.02, cex = 1.25)
```

<p id="biplot2">&nbsp;</p>

We can see some interesting effects in Figure 5:

- there is obvious asymmetry in the biplot for the closed data (Figure 5(a)) which can make any effects hard to interpret, even if they were valid
- in the biplot for open (clr-transformed) data (Figure 5(b)), some of the elemental associations make sense (*e.g*. Sr-Na-Mg, the REEs Ce-La-Nd-Gd-(Y), Al with Cr, Th, and V (and possibly REEs), redox-sensitive elements Fe-Mn, *etc*.)
- some clustering of observations is apparent in Figure 5(b), *e.g*. some Saltmarsh sediments seem to be associated with high REE concentrations; drain sediments are mainly towards the lower left
  - we may see clearer clustering by plotting different pairs of principal components, *e.g*. PC1 *vs*. PC3, PC2 *vs*. PC3. Remember from above that six principal component dimensions possibly contain useful information.
  - also, the PCA procedure maximises multiple variance, not the separation between groups. There are other multivariate methods that can do that.

We might see clearer groupings based on a different factor, such as whether the
sample location has a tidal influence or not, or a finer categorisation by
individual wetland pond.

&nbsp;

Let's have a look at plotting other PCA dimensions (just for the clr-transformed data, since that's the correct way to do it). The output of the code below is in 
Figure 6.

```{r biplots-PCA-AF-newdims, fig.height=12, fig.width=8, fig.align='center', fig.cap="Figure 6: PCA biplots for Ashfield data, with observations categorised by sample type for: (a) PC3 vs. PC1; (b) PC4 vs. PC1; (c) PC3 vs. PC2; (d) PC4 vs. PC2; (e) PC4 vs. PC3.", results='hold'}
data0 <- na.omit(ashfield_clr[,c(3,4,11:38)])
palette(c("black","moccasin","cyan2","navy","gray33"))
par(mfrow=c(3,2), mar = c(3,3,3,3), oma = c(0,0,0,0), 
    mgp=c(1.3,0.2,0), tcl = 0.25, font.lab=2, cex.lab=1.2,
    lend = "square", ljoin = "mitre")
v1list <- c(1,1,2,2,3) ; v2list <- c(3,4,3,4,4)
s0 <- 0.09 # components & scaling factor for this plot
for(i in 1:5){
  v1 <- v1list[i]; v2 <- v2list[i]; s0s <- c(0.09,0.12,0.14,0.12,0.14)
  biplot(pca_ashfield_open, choices = c(v1,v2), col = c("transparent",5), cex=c(0.8,1),
         pc.biplot = FALSE, scale = 0.2, arrow.len = 0.08,
         # xlim = c(-1.2,3.2), ylim = c(-3.5,1.7),
         xlab = paste0("Scaled PC",v1," Component Loadings"),
         ylab = paste0("Scaled PC",v2," Component Loadings")) 
  mtext(paste0("Scaled PC",v1," Observation Scores"), 3, 1.3, font = 2, cex=0.8)
  mtext(paste0("Scaled PC",v2," Observation Scores"), 4, 1.3, font = 2, cex=0.8)
  points(pca_ashfield_open$x[,v1]*s0s[i], pca_ashfield_open$x[,v2]*s0s[i],
         pch = c(22,21,24)[data0$Type],
         lwd = 1, bg = c(2,3,4)[data0$Type],
         col = 1,
         cex = c(1.2,1.4,1)[data0$Type])
  mtext(paste0("(",letters[i],") PC",v2," vs. PC",v1), 
        side = 3, line = -1.5, font = 2, adj = 0.02)
}
plot(0:1,0:1, type="n",bty="n",axes=F,ann=F)
legend("topleft", bty = "o", inset = 0.03,
        box.col = "gray", box.lwd = 2, bg = "white",
        legend = levels(data0$Type), title="Sample Type",
         pch = c(22,21,24), pt.lwd = 1,
         col = 1, pt.bg = c(2,3,4),
         pt.cex = c(1.2, 1.4, 1)*1.4,
         cex = 1.4, y.intersp = 0.9)
```

&nbsp;

Alternatively we could look at a 3D plot (Figure 7) susing the `scatterplot3d` package.

```{r pca-obs-3D, fig.cap="Figure 7: Plot of (a) observation scores and (b) component (variable) loadings for PCA on clr-transformed sediment elemental concentrations from Ashfield Flats 2019-2021.", fig.height=5, fig.width=12}
library(scatterplot3d)
data0 <- na.omit(ashfield_clr[,c(3,4,11:38)])
palette(c("black",colorRampPalette(c("navy","cyan2","moccasin"))(7),
          "grey","#ffffffa0"))
par(mfrow=c(1,2), mgp=c(1.6,0.2,0), font.lab=2)
s3d <- scatterplot3d(x=pca_ashfield_open$x[,1], 
                     y=pca_ashfield_open$x[,2], 
                     z=pca_ashfield_open$x[,3], mar=c(3,3,1,2.6),
              box=T, grid=T, type="p", col.axis="grey", angle=25, scale.y = 0.8, 
              bg = c(2,5,8)[data0$Type], 
              pch = c(21,22,23)[data0$Type], main="(a)",
              xlab="PC1 observation score", ylab="PC2 observation score",zlab="PC3 observation score")
legend(s3d$xyz.convert(-11, 0, -4), legend = levels(data0$Type),
      title="Sample Type", pt.bg= c(2,5,8), pch=c(21,22,23), box.col=10, bg=10)
s3d <- scatterplot3d(x=pca_ashfield_open$rotation[,1], 
                     y=pca_ashfield_open$rotation[,2], 
                     z=pca_ashfield_open$rotation[,3], mar=c(3,3,1,2.6),
                     box=T, grid=T, type="p", col.axis="grey", angle=25, scale.y = 0.75, 
                     pch = 1, cex.symbols=3, color="gray", main="(b)",
                     xlab="PC1 Variable Rotation", ylab="PC2 Variable Rotation",zlab="PC3 Variable Rotation")
text(s3d$xyz.convert(pca_ashfield_open$rotation[, 1:3]), labels = rownames(pca_ashfield_open$rotation),
     cex= 0.85)
```

&nbsp;

### References and R Packages

Fox, J. (2022). *RcmdrMisc: R Commander Miscellaneous Functions*. R package
version 2.7-2. [https://CRAN.R-project.org/package=RcmdrMisc](https://CRAN.R-project.org/package=RcmdrMisc){target="_blank"}

John Fox and Sanford Weisberg (2019). *An {R} Companion to Applied Regression*
(**car**), Third Edition. Thousand Oaks CA: Sage. URL:
[https://socialsciences.mcmaster.ca/jfox/Books/Companion/](https://socialsciences.mcmaster.ca/jfox/Books/Companion/){target="_blank"}

Greenacre, M. (2018). *Compositional Data Analysis in Practice*. CRC Press LLC, 
Boca Raton, FL, USA. 

Hu, J., Wang, Y., TaubenbÃ¶ck, H., Zhu, X.X. (2021). Land consumption in cities:
A comparative study across the globe. *Cities*, **113**: 103163,
[https://doi.org/10.1016/j.cities.2021.103163](https://doi.org/10.1016/j.cities.2021.103163){target="_blank"}.

Kassambara, A. and Mundt, F. (2020). *factoextra: Extract and Visualize the
Results of Multivariate Data Analyses*. R package version 1.0.7.
[https://CRAN.R-project.org/package=factoextra](https://CRAN.R-project.org/package=factoextra){target="_blank"}

Rate, A.W., & McGrath, G. (2022a). Sediment and soil quality at Ashfield Flats Reserve, Western Australia (Version 1). *Mendeley Data*, [doi:10.17632/d7m3746byk.1](https://doi.org/10.17632/d7m3746byk.1){target="_blank"}

Rate, A. W., & McGrath, G. S. (2022b). Data for assessment of sediment, soil, and water quality at Ashfield Flats Reserve, Western Australia. *Data in Brief*, **41**, 107970. [doi:10.1016/j.dib.2022.107970](https://doi.org/10.1016/j.dib.2022.107970){target="_blank"}

Reimann, C., Filzmoser, P., Garrett, R. G., & Dutter, R. (2008). *Statistical
Data Analysis Explained: Applied Environmental Statistics with R* (First ed.).
John Wiley & Sons, Chichester, UK.

Venables, W. N. & Ripley, B. D. (2002) *Modern Applied Statistics with S*
(**MASS**). Fourth Edition. Springer, New York. ISBN 0-387-95457-0.
[http://www.stats.ox.ac.uk/pub/MASS4/](http://www.stats.ox.ac.uk/pub/MASS4/){target="_blank"}

Wickham, H. (2019). *stringr: Simple, Consistent Wrappers for Common String
Operations*. R package version 1.4.0.
[https://CRAN.R-project.org/package=stringr](https://CRAN.R-project.org/package=stringr){target="_blank"}

Xu, N., Rate, A. W., & Morgan, B. (2018). From source to sink: Rare-earth
elements trace the legacy of sulfuric dredge spoils on estuarine sediments.
*Science of The Total Environment*, **637-638**, 1537-1549.
[https://doi.org/10.1016/j.scitotenv.2018.04.398](https://doi.org/10.1016/j.scitotenv.2018.04.398){target="_blank"}
